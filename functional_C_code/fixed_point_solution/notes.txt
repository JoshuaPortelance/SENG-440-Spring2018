Sample X:
    unsigned 16 bit integer
    between: 0 <= x <= 1
    /2^15
    
1/8 constant:
    (1/8) * 2^15 = 0x1000

X * 255
    255 * 2^8 = 0xFF00 = 1111 1111 . 0000 0000
    X = x . xxx xxxx xxxx xxxx
    need to move X's decimal to the right by 7 spots
        right shift 7 positions
        
1 + (X * 255)
    constant 1 * 2^15 = 0x8000
    0x8000 = 1.000 0000 0000 0000
    The result of X * 255 is in the form xxxx xxxx . xxxx xxxx
    Need to move the decimal for the 1 constant right 7 spots
        right shifted 7
    Then perform addition
        There may be a carry so output will be 17 bit
            x xxxx xxxx . xxxx xxxx
        Then need to truncate so right shift result by 1
            xxxx xxxx . xxxx xxxx
        
now perform the peicewise log
    output should be 8 bit?
    
    
float fpwlog2(float x) {
    /*
     *  All constants are / 2^8
     */ 

    if( x < 0x100) {
        return 0xFFFFF; // Error.
    }
    if( x < 0x200) {
        return( x - 0x100);
    }
    if( x < 0x400) {
        return( 0x100 + (x - 0x200) * 0x80);    // / 2.0 == * 0.5 * 2^8 = 0x80
    }
    if( x < 0x800) {
        return( 0x200 + (x - 0x400) * 0x40);     // / 4.0 == * .25
    }
    if( x < 0x1000) {
        return( 0x300 + (x - 0x800) * 0x20);
    }
    if( x < 0x2000) {
        return( 0x400 + (x - 0x1000) * 0x10);
    }
    if( x < 0x4000) {
        return( 0x500 + (x - 0x2000) * 0x8);
    }
    if( x < 0x8000) {
        return( 0x600 + (x - 0x4000) * 0x4);
    }
    if( x < 0x10000) {
        return( 0x700 + (x - 0x8000) * 0x2);
    }
    return 0xFFFFF; // Error.
}

Perform truncation to 8 bit?
    xxxx xxxx . xxxx xxxx
    shift right by 8
    xxxx xxxx
    
    
    
    
Lecture Notes:
    can assume that 100 gate delays is 1 cycle.
        Add an estimate of latency in cycle counts to our report for the non optimized and optimized code to show the improvement
    